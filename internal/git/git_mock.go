// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package git

import (
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &ClientMock{
//			AddWorktreeFunc: func(path string, branch string) error {
//				panic("mock out the AddWorktree method")
//			},
//			AddWorktreeNewBranchFunc: func(path string, branch string, base string) error {
//				panic("mock out the AddWorktreeNewBranch method")
//			},
//			BranchExistsFunc: func(name string) (bool, error) {
//				panic("mock out the BranchExists method")
//			},
//			DeleteBranchFunc: func(name string) error {
//				panic("mock out the DeleteBranch method")
//			},
//			DeleteBranchFromFunc: func(dir string, name string) error {
//				panic("mock out the DeleteBranchFrom method")
//			},
//			GitCommonDirFunc: func() (string, error) {
//				panic("mock out the GitCommonDir method")
//			},
//			HasUncommittedChangesFunc: func(worktreePath string) (bool, error) {
//				panic("mock out the HasUncommittedChanges method")
//			},
//			IsMergedFunc: func(branch string, base string) (bool, error) {
//				panic("mock out the IsMerged method")
//			},
//			ListBranchesFunc: func() ([]string, error) {
//				panic("mock out the ListBranches method")
//			},
//			ListWorktreesFunc: func() ([]Worktree, error) {
//				panic("mock out the ListWorktrees method")
//			},
//			RemoteGetURLFunc: func(remote string) (string, error) {
//				panic("mock out the RemoteGetURL method")
//			},
//			RemoveWorktreeFunc: func(path string) error {
//				panic("mock out the RemoveWorktree method")
//			},
//			RenameBranchFunc: func(old string, new string) error {
//				panic("mock out the RenameBranch method")
//			},
//			RepairWorktreesFunc: func() error {
//				panic("mock out the RepairWorktrees method")
//			},
//			SymbolicRefFunc: func(ref string) (string, error) {
//				panic("mock out the SymbolicRef method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// AddWorktreeFunc mocks the AddWorktree method.
	AddWorktreeFunc func(path string, branch string) error

	// AddWorktreeNewBranchFunc mocks the AddWorktreeNewBranch method.
	AddWorktreeNewBranchFunc func(path string, branch string, base string) error

	// BranchExistsFunc mocks the BranchExists method.
	BranchExistsFunc func(name string) (bool, error)

	// DeleteBranchFunc mocks the DeleteBranch method.
	DeleteBranchFunc func(name string) error

	// DeleteBranchFromFunc mocks the DeleteBranchFrom method.
	DeleteBranchFromFunc func(dir string, name string) error

	// GitCommonDirFunc mocks the GitCommonDir method.
	GitCommonDirFunc func() (string, error)

	// HasUncommittedChangesFunc mocks the HasUncommittedChanges method.
	HasUncommittedChangesFunc func(worktreePath string) (bool, error)

	// IsMergedFunc mocks the IsMerged method.
	IsMergedFunc func(branch string, base string) (bool, error)

	// ListBranchesFunc mocks the ListBranches method.
	ListBranchesFunc func() ([]string, error)

	// ListWorktreesFunc mocks the ListWorktrees method.
	ListWorktreesFunc func() ([]Worktree, error)

	// RemoteGetURLFunc mocks the RemoteGetURL method.
	RemoteGetURLFunc func(remote string) (string, error)

	// RemoveWorktreeFunc mocks the RemoveWorktree method.
	RemoveWorktreeFunc func(path string) error

	// RenameBranchFunc mocks the RenameBranch method.
	RenameBranchFunc func(old string, new string) error

	// RepairWorktreesFunc mocks the RepairWorktrees method.
	RepairWorktreesFunc func() error

	// SymbolicRefFunc mocks the SymbolicRef method.
	SymbolicRefFunc func(ref string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddWorktree holds details about calls to the AddWorktree method.
		AddWorktree []struct {
			// Path is the path argument value.
			Path string
			// Branch is the branch argument value.
			Branch string
		}
		// AddWorktreeNewBranch holds details about calls to the AddWorktreeNewBranch method.
		AddWorktreeNewBranch []struct {
			// Path is the path argument value.
			Path string
			// Branch is the branch argument value.
			Branch string
			// Base is the base argument value.
			Base string
		}
		// BranchExists holds details about calls to the BranchExists method.
		BranchExists []struct {
			// Name is the name argument value.
			Name string
		}
		// DeleteBranch holds details about calls to the DeleteBranch method.
		DeleteBranch []struct {
			// Name is the name argument value.
			Name string
		}
		// DeleteBranchFrom holds details about calls to the DeleteBranchFrom method.
		DeleteBranchFrom []struct {
			// Dir is the dir argument value.
			Dir string
			// Name is the name argument value.
			Name string
		}
		// GitCommonDir holds details about calls to the GitCommonDir method.
		GitCommonDir []struct {
		}
		// HasUncommittedChanges holds details about calls to the HasUncommittedChanges method.
		HasUncommittedChanges []struct {
			// WorktreePath is the worktreePath argument value.
			WorktreePath string
		}
		// IsMerged holds details about calls to the IsMerged method.
		IsMerged []struct {
			// Branch is the branch argument value.
			Branch string
			// Base is the base argument value.
			Base string
		}
		// ListBranches holds details about calls to the ListBranches method.
		ListBranches []struct {
		}
		// ListWorktrees holds details about calls to the ListWorktrees method.
		ListWorktrees []struct {
		}
		// RemoteGetURL holds details about calls to the RemoteGetURL method.
		RemoteGetURL []struct {
			// Remote is the remote argument value.
			Remote string
		}
		// RemoveWorktree holds details about calls to the RemoveWorktree method.
		RemoveWorktree []struct {
			// Path is the path argument value.
			Path string
		}
		// RenameBranch holds details about calls to the RenameBranch method.
		RenameBranch []struct {
			// Old is the old argument value.
			Old string
			// New is the new argument value.
			New string
		}
		// RepairWorktrees holds details about calls to the RepairWorktrees method.
		RepairWorktrees []struct {
		}
		// SymbolicRef holds details about calls to the SymbolicRef method.
		SymbolicRef []struct {
			// Ref is the ref argument value.
			Ref string
		}
	}
	lockAddWorktree           sync.RWMutex
	lockAddWorktreeNewBranch  sync.RWMutex
	lockBranchExists          sync.RWMutex
	lockDeleteBranch          sync.RWMutex
	lockDeleteBranchFrom      sync.RWMutex
	lockGitCommonDir          sync.RWMutex
	lockHasUncommittedChanges sync.RWMutex
	lockIsMerged              sync.RWMutex
	lockListBranches          sync.RWMutex
	lockListWorktrees         sync.RWMutex
	lockRemoteGetURL          sync.RWMutex
	lockRemoveWorktree        sync.RWMutex
	lockRenameBranch          sync.RWMutex
	lockRepairWorktrees       sync.RWMutex
	lockSymbolicRef           sync.RWMutex
}

// AddWorktree calls AddWorktreeFunc.
func (mock *ClientMock) AddWorktree(path string, branch string) error {
	if mock.AddWorktreeFunc == nil {
		panic("ClientMock.AddWorktreeFunc: method is nil but Client.AddWorktree was just called")
	}
	callInfo := struct {
		Path   string
		Branch string
	}{
		Path:   path,
		Branch: branch,
	}
	mock.lockAddWorktree.Lock()
	mock.calls.AddWorktree = append(mock.calls.AddWorktree, callInfo)
	mock.lockAddWorktree.Unlock()
	return mock.AddWorktreeFunc(path, branch)
}

// AddWorktreeCalls gets all the calls that were made to AddWorktree.
// Check the length with:
//
//	len(mockedClient.AddWorktreeCalls())
func (mock *ClientMock) AddWorktreeCalls() []struct {
	Path   string
	Branch string
} {
	var calls []struct {
		Path   string
		Branch string
	}
	mock.lockAddWorktree.RLock()
	calls = mock.calls.AddWorktree
	mock.lockAddWorktree.RUnlock()
	return calls
}

// AddWorktreeNewBranch calls AddWorktreeNewBranchFunc.
func (mock *ClientMock) AddWorktreeNewBranch(path string, branch string, base string) error {
	if mock.AddWorktreeNewBranchFunc == nil {
		panic("ClientMock.AddWorktreeNewBranchFunc: method is nil but Client.AddWorktreeNewBranch was just called")
	}
	callInfo := struct {
		Path   string
		Branch string
		Base   string
	}{
		Path:   path,
		Branch: branch,
		Base:   base,
	}
	mock.lockAddWorktreeNewBranch.Lock()
	mock.calls.AddWorktreeNewBranch = append(mock.calls.AddWorktreeNewBranch, callInfo)
	mock.lockAddWorktreeNewBranch.Unlock()
	return mock.AddWorktreeNewBranchFunc(path, branch, base)
}

// AddWorktreeNewBranchCalls gets all the calls that were made to AddWorktreeNewBranch.
// Check the length with:
//
//	len(mockedClient.AddWorktreeNewBranchCalls())
func (mock *ClientMock) AddWorktreeNewBranchCalls() []struct {
	Path   string
	Branch string
	Base   string
} {
	var calls []struct {
		Path   string
		Branch string
		Base   string
	}
	mock.lockAddWorktreeNewBranch.RLock()
	calls = mock.calls.AddWorktreeNewBranch
	mock.lockAddWorktreeNewBranch.RUnlock()
	return calls
}

// BranchExists calls BranchExistsFunc.
func (mock *ClientMock) BranchExists(name string) (bool, error) {
	if mock.BranchExistsFunc == nil {
		panic("ClientMock.BranchExistsFunc: method is nil but Client.BranchExists was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockBranchExists.Lock()
	mock.calls.BranchExists = append(mock.calls.BranchExists, callInfo)
	mock.lockBranchExists.Unlock()
	return mock.BranchExistsFunc(name)
}

// BranchExistsCalls gets all the calls that were made to BranchExists.
// Check the length with:
//
//	len(mockedClient.BranchExistsCalls())
func (mock *ClientMock) BranchExistsCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockBranchExists.RLock()
	calls = mock.calls.BranchExists
	mock.lockBranchExists.RUnlock()
	return calls
}

// DeleteBranch calls DeleteBranchFunc.
func (mock *ClientMock) DeleteBranch(name string) error {
	if mock.DeleteBranchFunc == nil {
		panic("ClientMock.DeleteBranchFunc: method is nil but Client.DeleteBranch was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockDeleteBranch.Lock()
	mock.calls.DeleteBranch = append(mock.calls.DeleteBranch, callInfo)
	mock.lockDeleteBranch.Unlock()
	return mock.DeleteBranchFunc(name)
}

// DeleteBranchCalls gets all the calls that were made to DeleteBranch.
// Check the length with:
//
//	len(mockedClient.DeleteBranchCalls())
func (mock *ClientMock) DeleteBranchCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockDeleteBranch.RLock()
	calls = mock.calls.DeleteBranch
	mock.lockDeleteBranch.RUnlock()
	return calls
}

// DeleteBranchFrom calls DeleteBranchFromFunc.
func (mock *ClientMock) DeleteBranchFrom(dir string, name string) error {
	if mock.DeleteBranchFromFunc == nil {
		panic("ClientMock.DeleteBranchFromFunc: method is nil but Client.DeleteBranchFrom was just called")
	}
	callInfo := struct {
		Dir  string
		Name string
	}{
		Dir:  dir,
		Name: name,
	}
	mock.lockDeleteBranchFrom.Lock()
	mock.calls.DeleteBranchFrom = append(mock.calls.DeleteBranchFrom, callInfo)
	mock.lockDeleteBranchFrom.Unlock()
	return mock.DeleteBranchFromFunc(dir, name)
}

// DeleteBranchFromCalls gets all the calls that were made to DeleteBranchFrom.
// Check the length with:
//
//	len(mockedClient.DeleteBranchFromCalls())
func (mock *ClientMock) DeleteBranchFromCalls() []struct {
	Dir  string
	Name string
} {
	var calls []struct {
		Dir  string
		Name string
	}
	mock.lockDeleteBranchFrom.RLock()
	calls = mock.calls.DeleteBranchFrom
	mock.lockDeleteBranchFrom.RUnlock()
	return calls
}

// GitCommonDir calls GitCommonDirFunc.
func (mock *ClientMock) GitCommonDir() (string, error) {
	if mock.GitCommonDirFunc == nil {
		panic("ClientMock.GitCommonDirFunc: method is nil but Client.GitCommonDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGitCommonDir.Lock()
	mock.calls.GitCommonDir = append(mock.calls.GitCommonDir, callInfo)
	mock.lockGitCommonDir.Unlock()
	return mock.GitCommonDirFunc()
}

// GitCommonDirCalls gets all the calls that were made to GitCommonDir.
// Check the length with:
//
//	len(mockedClient.GitCommonDirCalls())
func (mock *ClientMock) GitCommonDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGitCommonDir.RLock()
	calls = mock.calls.GitCommonDir
	mock.lockGitCommonDir.RUnlock()
	return calls
}

// HasUncommittedChanges calls HasUncommittedChangesFunc.
func (mock *ClientMock) HasUncommittedChanges(worktreePath string) (bool, error) {
	if mock.HasUncommittedChangesFunc == nil {
		panic("ClientMock.HasUncommittedChangesFunc: method is nil but Client.HasUncommittedChanges was just called")
	}
	callInfo := struct {
		WorktreePath string
	}{
		WorktreePath: worktreePath,
	}
	mock.lockHasUncommittedChanges.Lock()
	mock.calls.HasUncommittedChanges = append(mock.calls.HasUncommittedChanges, callInfo)
	mock.lockHasUncommittedChanges.Unlock()
	return mock.HasUncommittedChangesFunc(worktreePath)
}

// HasUncommittedChangesCalls gets all the calls that were made to HasUncommittedChanges.
// Check the length with:
//
//	len(mockedClient.HasUncommittedChangesCalls())
func (mock *ClientMock) HasUncommittedChangesCalls() []struct {
	WorktreePath string
} {
	var calls []struct {
		WorktreePath string
	}
	mock.lockHasUncommittedChanges.RLock()
	calls = mock.calls.HasUncommittedChanges
	mock.lockHasUncommittedChanges.RUnlock()
	return calls
}

// IsMerged calls IsMergedFunc.
func (mock *ClientMock) IsMerged(branch string, base string) (bool, error) {
	if mock.IsMergedFunc == nil {
		panic("ClientMock.IsMergedFunc: method is nil but Client.IsMerged was just called")
	}
	callInfo := struct {
		Branch string
		Base   string
	}{
		Branch: branch,
		Base:   base,
	}
	mock.lockIsMerged.Lock()
	mock.calls.IsMerged = append(mock.calls.IsMerged, callInfo)
	mock.lockIsMerged.Unlock()
	return mock.IsMergedFunc(branch, base)
}

// IsMergedCalls gets all the calls that were made to IsMerged.
// Check the length with:
//
//	len(mockedClient.IsMergedCalls())
func (mock *ClientMock) IsMergedCalls() []struct {
	Branch string
	Base   string
} {
	var calls []struct {
		Branch string
		Base   string
	}
	mock.lockIsMerged.RLock()
	calls = mock.calls.IsMerged
	mock.lockIsMerged.RUnlock()
	return calls
}

// ListBranches calls ListBranchesFunc.
func (mock *ClientMock) ListBranches() ([]string, error) {
	if mock.ListBranchesFunc == nil {
		panic("ClientMock.ListBranchesFunc: method is nil but Client.ListBranches was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListBranches.Lock()
	mock.calls.ListBranches = append(mock.calls.ListBranches, callInfo)
	mock.lockListBranches.Unlock()
	return mock.ListBranchesFunc()
}

// ListBranchesCalls gets all the calls that were made to ListBranches.
// Check the length with:
//
//	len(mockedClient.ListBranchesCalls())
func (mock *ClientMock) ListBranchesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListBranches.RLock()
	calls = mock.calls.ListBranches
	mock.lockListBranches.RUnlock()
	return calls
}

// ListWorktrees calls ListWorktreesFunc.
func (mock *ClientMock) ListWorktrees() ([]Worktree, error) {
	if mock.ListWorktreesFunc == nil {
		panic("ClientMock.ListWorktreesFunc: method is nil but Client.ListWorktrees was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListWorktrees.Lock()
	mock.calls.ListWorktrees = append(mock.calls.ListWorktrees, callInfo)
	mock.lockListWorktrees.Unlock()
	return mock.ListWorktreesFunc()
}

// ListWorktreesCalls gets all the calls that were made to ListWorktrees.
// Check the length with:
//
//	len(mockedClient.ListWorktreesCalls())
func (mock *ClientMock) ListWorktreesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListWorktrees.RLock()
	calls = mock.calls.ListWorktrees
	mock.lockListWorktrees.RUnlock()
	return calls
}

// RemoteGetURL calls RemoteGetURLFunc.
func (mock *ClientMock) RemoteGetURL(remote string) (string, error) {
	if mock.RemoteGetURLFunc == nil {
		panic("ClientMock.RemoteGetURLFunc: method is nil but Client.RemoteGetURL was just called")
	}
	callInfo := struct {
		Remote string
	}{
		Remote: remote,
	}
	mock.lockRemoteGetURL.Lock()
	mock.calls.RemoteGetURL = append(mock.calls.RemoteGetURL, callInfo)
	mock.lockRemoteGetURL.Unlock()
	return mock.RemoteGetURLFunc(remote)
}

// RemoteGetURLCalls gets all the calls that were made to RemoteGetURL.
// Check the length with:
//
//	len(mockedClient.RemoteGetURLCalls())
func (mock *ClientMock) RemoteGetURLCalls() []struct {
	Remote string
} {
	var calls []struct {
		Remote string
	}
	mock.lockRemoteGetURL.RLock()
	calls = mock.calls.RemoteGetURL
	mock.lockRemoteGetURL.RUnlock()
	return calls
}

// RemoveWorktree calls RemoveWorktreeFunc.
func (mock *ClientMock) RemoveWorktree(path string) error {
	if mock.RemoveWorktreeFunc == nil {
		panic("ClientMock.RemoveWorktreeFunc: method is nil but Client.RemoveWorktree was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockRemoveWorktree.Lock()
	mock.calls.RemoveWorktree = append(mock.calls.RemoveWorktree, callInfo)
	mock.lockRemoveWorktree.Unlock()
	return mock.RemoveWorktreeFunc(path)
}

// RemoveWorktreeCalls gets all the calls that were made to RemoveWorktree.
// Check the length with:
//
//	len(mockedClient.RemoveWorktreeCalls())
func (mock *ClientMock) RemoveWorktreeCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockRemoveWorktree.RLock()
	calls = mock.calls.RemoveWorktree
	mock.lockRemoveWorktree.RUnlock()
	return calls
}

// RenameBranch calls RenameBranchFunc.
func (mock *ClientMock) RenameBranch(old string, new string) error {
	if mock.RenameBranchFunc == nil {
		panic("ClientMock.RenameBranchFunc: method is nil but Client.RenameBranch was just called")
	}
	callInfo := struct {
		Old string
		New string
	}{
		Old: old,
		New: new,
	}
	mock.lockRenameBranch.Lock()
	mock.calls.RenameBranch = append(mock.calls.RenameBranch, callInfo)
	mock.lockRenameBranch.Unlock()
	return mock.RenameBranchFunc(old, new)
}

// RenameBranchCalls gets all the calls that were made to RenameBranch.
// Check the length with:
//
//	len(mockedClient.RenameBranchCalls())
func (mock *ClientMock) RenameBranchCalls() []struct {
	Old string
	New string
} {
	var calls []struct {
		Old string
		New string
	}
	mock.lockRenameBranch.RLock()
	calls = mock.calls.RenameBranch
	mock.lockRenameBranch.RUnlock()
	return calls
}

// RepairWorktrees calls RepairWorktreesFunc.
func (mock *ClientMock) RepairWorktrees() error {
	if mock.RepairWorktreesFunc == nil {
		panic("ClientMock.RepairWorktreesFunc: method is nil but Client.RepairWorktrees was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRepairWorktrees.Lock()
	mock.calls.RepairWorktrees = append(mock.calls.RepairWorktrees, callInfo)
	mock.lockRepairWorktrees.Unlock()
	return mock.RepairWorktreesFunc()
}

// RepairWorktreesCalls gets all the calls that were made to RepairWorktrees.
// Check the length with:
//
//	len(mockedClient.RepairWorktreesCalls())
func (mock *ClientMock) RepairWorktreesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRepairWorktrees.RLock()
	calls = mock.calls.RepairWorktrees
	mock.lockRepairWorktrees.RUnlock()
	return calls
}

// SymbolicRef calls SymbolicRefFunc.
func (mock *ClientMock) SymbolicRef(ref string) (string, error) {
	if mock.SymbolicRefFunc == nil {
		panic("ClientMock.SymbolicRefFunc: method is nil but Client.SymbolicRef was just called")
	}
	callInfo := struct {
		Ref string
	}{
		Ref: ref,
	}
	mock.lockSymbolicRef.Lock()
	mock.calls.SymbolicRef = append(mock.calls.SymbolicRef, callInfo)
	mock.lockSymbolicRef.Unlock()
	return mock.SymbolicRefFunc(ref)
}

// SymbolicRefCalls gets all the calls that were made to SymbolicRef.
// Check the length with:
//
//	len(mockedClient.SymbolicRefCalls())
func (mock *ClientMock) SymbolicRefCalls() []struct {
	Ref string
} {
	var calls []struct {
		Ref string
	}
	mock.lockSymbolicRef.RLock()
	calls = mock.calls.SymbolicRef
	mock.lockSymbolicRef.RUnlock()
	return calls
}
